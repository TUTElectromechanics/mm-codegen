#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Code generator for evaluating the partial derivatives of the potential ϕ.

stage2.py takes in the code generated by stage1. It analyzes the dependencies
between the functions, and generates wrapper functions, where all bound symbols
(quantities defined by any of the stage1 generated functions) are automatically
computed, by calling the standalone pieces generated in stage1 (recursing
where necessary).

Each function generated by stage2 takes in values only for the free symbols
(quantities *not* defined by any of the stage1 generated functions)
encountered anywhere in its call tree. This makes e.g. ∂²ϕ/∂Bx² "see" the
dependencies on e.g. u0, I4, and εxx.

Created on Tue Oct 24 14:07:45 2017

@author: jje
"""

import re

##############################################################################
# High-level code generator
##############################################################################

class CodeGenerator:
    """Generate code to call the sequences of functions generated by SymbolicModelDeriver."""

    def __init__(self, data):
        """Constructor.

        Parameters:
            data: tuple of tuples
                Each item should have (label, filename, content).
                This is the output format of SymbolicModelDeriver.run().
"""
        # we need to analyze only the interfaces (headers, ".h")
        self.data = [(label,fn,content) for label,fn,content in data if fn.endswith(".h")]

    @staticmethod
    def analyze_interface(code):
        """Extract function call dependencies from a Fortran interface.

        This is very simplistic, and likely specific to code generated
        by SymPy's code generator.

        Only functions are supported; subroutines are ignored.

        Parameters:
            code: str
                Content of a Fortran interface (".h" file), as a single string.

        Return value: (funcs, lookup), where
            funcs: tuple of tuples
                Each item has the format (fname, arg1, arg2, ..., argn)
                Ordering of the args is preserved.

            lookup: dictionary
                lookup[fname] = (arg1, arg2, ..., argn)
                This is provided for convenience.
"""
        # HACK: We parse by regex matching. Use a proper Fortran parser?
        #
        from enum import Enum
        class ReaderState(Enum):
            SCANNING  = 0
            CAPTURING = 1

        def commit(fname, fargs):
            result.append( (fname, fargs) )

        def function_header_ends(line):
            endparen = re.findall(r"\)", line)
            return (len(endparen) > 0)

        result = []
        state = ReaderState.SCANNING
        for line in code.split("\n"):
            if state == ReaderState.SCANNING:
                # match "function" but not "end function" (see "help re")
                m = re.findall(r"(?<!\bend\b)\s+\bfunction\b", line)

                if len(m):  # if found, start capturing
                    # - skip keyword "function" and whitespace
                    # - capture function name (non-whitespace, 1 or more)
                    # - then skip "("
                    # - finally capture arguments:
                    #     - up to end of line, 0 or more of anything that is not "&" or ")"
                    #     - *0* or more because some functions might not take any arguments!
                    matches = re.findall(r"\bfunction\b\s+(\S+)\(([^&)]*)", line)
                    assert len(matches) == 1  # should be just one match for the whole regex
                    groups = matches[0]

                    fname = groups[0]
                    fargs = groups[1].strip().split(",")
                    fargs = [s.strip() for s in fargs if len(s.strip())]
#                    print("Function '%s'" % (fname))  # DEBUG

                    # Before we change state, we must check whether the whole
                    # function header was on this line.
                    #
                    # If so, commit and resume scanning; else change state
                    # to capture the rest of fargs from the following lines.
                    #
                    if function_header_ends(line):
                        commit(fname, fargs)
                    else:
                        state = ReaderState.CAPTURING

            elif state == ReaderState.CAPTURING:
                # capture function arguments from this line
                groups = re.findall(r"[^&)]+", line)  # one group only, no wrapper
                morefargs = groups[0].strip().split(",")
                morefargs = [s.strip() for s in morefargs if len(s.strip())]
                fargs.extend(morefargs)

                # If these were the last fargs, commit and resume scanning.
                if function_header_ends(line):
                    commit(fname, fargs)
                    state = ReaderState.SCANNING

            else:
                assert False, "Unknown reader state"

        # When we finish, the reader should NOT be in the CAPTURING state,
        # as that indicates that a function header was not terminated correctly.
        #
        if state == ReaderState.CAPTURING:
            raise ValueError("End of file while capturing function arguments for '%s'" % (fname))

        return (result, {fname:args for fname,args in result})

    def analyze_args(self, args, recurse, level=0):
        """Split args to bound and free sets.

        Any argument names that exist in self.lookup are considered
        bound to those functions.

        All other arguments are considered free.

        Parameters:
            args: tuple of str
                Names of arguments used by a stage1 generated function.
                See analyze_interface().

            recurse: bool
                Whether to recurse into args.

            level: int
                Internal parameter that keeps track of the depth of recursion,
                i.e. how deep in the call tree the arg is needed.

                (Just leave this at its default value.)

        Returns:
            set of ``(level,arg)`` pairs
                where ``level`` is the recursion depth where ``arg`` was seen.

                0 means top level.

                ``i > 0`` means "needed by level ``i-1``".

                Note that the same arg may have been seen at multiple levels;
                each level then has its own instance in the results.
"""
        # Implemented using mutual recursion:
        #   - analyze_args() injects the level info into a raw args list
        #   - _analyze_args_internal() does the rest of the work
        return self._analyze_args_internal([(level,arg) for arg in args], recurse)
    def _analyze_args_internal(self, args, recurse):
        bound = set()
        free  = set()
        for item in args:
            level,arg = item
            if arg in self.lookup:  # if we know a function of this name
                bound.add((level,arg))
                if recurse:
                    b,f = self.analyze_args(self.lookup[arg], recurse, level+1)
                    bound.update(b)
                    free.update(f)
            else:
                free.add((level,arg))
        return (bound,free)
    @staticmethod
    def sorted_by_level(args):  # level first, then name as tie-breaker
        """Sort helper for output of analyze_args()."""
        return sorted(tuple(args), key=lambda item: (item[0], item[1]))
    @staticmethod
    def sorted_by_name(args):   # name first, then level as tie-breaker
        """Sort helper for output of analyze_args()."""
        return sorted(tuple(args), key=lambda item: (item[1], item[0]))
    @staticmethod
    def strip_levels(args):
        """Strip level information from output of analyze_args."""
        return [item[1] for item in args]

    def validate_bound_args(self, bound):
        """Validate bound args.

        Check that each bound argument calls other bound arguments of only
        strictly deeper levels, because our code generation algorithm
        is not designed to handle mutually recursive call sequences.

        If the check passes, it proves that the generated Fortran program
        cannot get stuck in an infinite recursion.

        (Strictly speaking, this only proves the non-recursiveness of the
        dependencies declared between the function definitions in the interface
        that was analyzed, and that only provided that the analysis is correct.

        We still need to rely on other means to make sure that the stage2
        analyzer and code generator are correct.)

        Parameters:
            bound: set of ``(level,arg)`` pairs
                as output by ``analyze_args()`` with ``recursive=True``.

        Returns:
            None
                ``ValueError`` is raised if the validity check fails.
"""
        # Find the shallowest (min) and deepest (max) level where
        # each bound arg was seen.
        #
        args = [arg for (_,arg) in bound]
        arg_to_level = {}
        for arg in args:
            levels = [l for (l,a) in bound if a == arg]
            minlevel = min(levels)
            maxlevel = max(levels)
            arg_to_level[arg] = (minlevel,maxlevel)

        # Validate.
        #
        # - Each arg may only call into args having levels strictly deeper
        #   than its own maxlevel. (The arg must be evaluable at *all* of its
        #   call sites, whence especially at the deepest one.)
        #
        # - When the arg calls another arg, the minlevel *of the other arg*
        #   must be > maxlevel *of this arg* (also to make sure that this arg,
        #   at its deepest call site, is evaluable).
        #
        # We dont need to recurse, because analyze_args() already gives us
        # a flattened list of all occurrences of each arg.
        #
        for arg,levels in arg_to_level.items():
            minlevel,maxlevel = levels
            deps = self.lookup[arg]  # other args this arg depends on
            for a in deps:
                if a in args:  # only validate if a is bound (free args may occur anywhere)
                    almin,almax = arg_to_level[a]  # max level where a was seen
                    if almin > maxlevel:
                        continue
                    raise ValueError("%s (max level %d) requires %s (min level %d); recursive calls not supported by this code generator" % (arg,maxlevel,a,almin))

    def run(self):
        """Generate the high-level code."""

        generated_code_output = []
        for i,item in enumerate(self.data):
            label,input_filename,content = item

            print("(%d/%d) Generating wrappers for '%s'" % (i+1, len(self.data), input_filename))

            output = \
"""!******************************************************************************
!*                 Code generated with mgs-galfenol-codegen                   *
!*                                                                            *
!*                 This file is part of 'elmer-mgs-galfenol'                  *
!******************************************************************************"""

            # Parse dependencies between the stage1 generated functions.
            #
            funcs,self.lookup = self.analyze_interface(content)

            # TODO: consolidated version that does not re-compute everything
            # (e.g. I6) for each output tensor component, but computes once
            # and re-uses the result.

            # To write the wrapper for a function f, we need two things:
            #
            #  - free args needed by f or anything it calls, recursively
            #      -> add to arg list of wrapper
            #  - bound args needed by f, locally
            #      -> call them in the function body of the wrapper,
            #         then use the obtained values
            #
            # This binds values to all arguments of f; we may then assign
            # them to temporary variables and call the original f.
            #
            # Note that in any *calls*, we must use data from funcs
            # (or lookup), because they preserve the original ordering
            # of args (which are positional in Fortran!); the sets of
            # bound and free arguments are only used for deciding
            # which action to perform with each symbol.
            #
            for fname,args in funcs:
#                # DEBUG
#                print(fname)
#                for arg in args:
#                    print("\t%s" % (arg))

                rbound,rfree = self.analyze_args(args, recurse=True)   # r=recursive
                lbound,lfree = self.analyze_args(args, recurse=False)  # l=local
#                print(fname, lbound, rfree)
                print(fname, self.strip_levels(self.sorted_by_name(lbound)),
                             self.strip_levels(self.sorted_by_name(lfree)))
                print(fname, self.sorted_by_name(rbound), self.sorted_by_name(rfree))
                self.validate_bound_args(rbound)

#                output += "REAL*8 function %s

                # TODO: finish implementing this

#            output_basename = "mgs_%s" % (label)
#            output_implname = "%s.f90" % (output_basename)
#            output_intfname = "%s.h"   % (output_basename)

#            generated_code_output.append( (label, output_implname, output_impl) )
#            generated_code_output.append( (label, output_implname, output_intf) )

        return generated_code_output

##############################################################################
# Testing
##############################################################################

def test():
    # TODO: just load files to run s2 test faster?
    import stage1
    s1gen = stage1.CodeGenerator()
    s1code = s1gen.run()

    s2gen = CodeGenerator(s1code)  # stage2 i.e. ours
    s2code = s2gen.run()

    # TODO: write to files

if __name__ == '__main__':
    test()
