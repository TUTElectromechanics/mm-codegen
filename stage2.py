#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Code generator for evaluating the partial derivatives of the potential ϕ.

Note ϕ = ϕ(u,v,w).

The derivatives ∂ϕ/∂u, ∂ϕ/∂v, ∂ϕ/∂w must be externally supplied; all the rest
are automatically generated by this module.

Created on Tue Oct 24 14:07:45 2017

@author: jje
"""

import re

##############################################################################
# High-level code generator
##############################################################################

class CodeGenerator:
    """Generate code to call the sequences of functions generated by SymbolicModelDeriver."""

    def __init__(self, data):
        """Constructor.

        Parameters:
            data: tuple of tuples
                Each item should have (label, filename, content).
                This is the output format of SymbolicModelDeriver.run().
"""
        # we need to analyze only the interfaces (headers, ".h")
        self.data = [(label,fn,content) for label,fn,content in data if fn.endswith(".h")]

    def analyze(self, code):
        """Extract function call dependencies from Fortran interfaces.

        This is very simplistic, and likely specific to code generated
        by SymPy's code generator.

        Only functions are supported; subroutines are ignored.

        Parameters:
            code: str
                Content of a Fortran interface (".h" file), as a single string.

        Return value:
            tuple of tuples:
                Each item has the format (fname, arg1, arg2, ..., argn)
                Ordering of the args is preserved.
"""
        # HACK: parse by regex matching.
        # TODO: use a proper Fortran parser?
        #
        from enum import Enum
        class ReaderState(Enum):
            SCANNING  = 0
            CAPTURING = 1

        def commit(fname, fargs):
            result.append( (fname, fargs) )

        def function_header_ends(line):
            endparen = re.findall(r"\)", line)
            return (len(endparen) > 0)

        result = []
        state = ReaderState.SCANNING
        for line in code.split("\n"):
            if state == ReaderState.SCANNING:
                # match "function" but not "end function" (see "help re")
                m = re.findall(r"(?<!\bend\b)\s+\bfunction\b", line)

                if len(m):  # if found, start capturing
                    # - skip keyword "function" and whitespace
                    # - capture function name (non-whitespace, 1 or more)
                    # - then skip "("
                    # - finally capture arguments:
                    #     - up to end of line, 0 or more of anything that is not "&" or ")"
                    #     - *0* or more because some functions might not take any arguments!
                    matches = re.findall(r"\bfunction\b\s+(\S+)\(([^&)]*)", line)
                    assert len(matches) == 1  # should be just one match for the whole regex
                    groups = matches[0]

                    fname = groups[0]
                    fargs = groups[1].strip().split(",")
                    fargs = [s.strip() for s in fargs if len(s.strip())]
#                    print("Function '%s'" % (fname))  # DEBUG

                    # Before we change state, we must check whether the whole
                    # function header was on this line.
                    #
                    # If so, commit and resume scanning; else change state
                    # to capture the rest of fargs from the following lines.
                    #
                    if function_header_ends(line):
                        commit(fname, fargs)
                    else:
                        state = ReaderState.CAPTURING

            elif state == ReaderState.CAPTURING:
                # capture function arguments from this line
                groups = re.findall(r"[^&)]+", line)  # one group only, no wrapper
                morefargs = groups[0].strip().split(",")
                morefargs = [s.strip() for s in morefargs if len(s.strip())]
                fargs.extend(morefargs)

                # If these were the last fargs, commit and resume scanning.
                if function_header_ends(line):
                    commit(fname, fargs)
                    state = ReaderState.SCANNING

            else:
                assert False, "Unknown reader state"

        # When we finish, the reader should NOT be in the CAPTURING state,
        # as that indicates that a function header was not terminated correctly.
        #
        if state == ReaderState.CAPTURING:
            raise ValueError("End of file while capturing function arguments for '%s'" % (fname))

        return result

    def run(self):
        """Generate the high-level code."""

        generated_code_output = []
        for i,item in enumerate(self.data):
            label,input_filename,content = item
    
            print("(%d/%d) Generating wrappers for '%s'" % (i+1, len(self.data), input_filename))

            output = \
"""!******************************************************************************
!*                 Code generated with mgs-galfenol-codegen                   *
!*                                                                            *
!*                 This file is part of 'elmer-mgs-galfenol'                  *
!******************************************************************************"""

            # Parse dependencies within the generated low-level module
            #
            funcs = self.analyze(content)
            lookup = {fname:args for fname,args in funcs}

            # TODO: consolidated version that does not re-compute everything
            # (e.g. I6) for each output tensor component, but computes once
            # and re-uses the result.

            # Split args to bound and free sets.
            #
            # - any argument names that exist in funcs are considered bound
            #   to those functions
            # - all other arguments are free
            #
            # - "level" keeps track of the depth of recursion i.e. how deep
            #   in the call tree the arg is needed.
            #   - 0 means top level
            #   - i > 0 means "needed by level i-1"
            #
            # - Mutual recursion:
            #   - analyze_args() is the public API, and injects the level info
            #   - _analyze_args_internal() does the work, but uses analyze_args()
            #     to inject level information into the raw arg list
            #
            def analyze_args(args, recurse, level=0):
                return _analyze_args_internal([(level,arg) for arg in args], recurse)
            def _analyze_args_internal(args, recurse):
                bound = set()
                free  = set()
                for item in args:
                    print(item)
                    level,arg = item
                    if arg in lookup:  # if we know a function of this name
                        bound.add((level,arg))
                        if recurse:
                            b,f = analyze_args(lookup[arg], recurse, level+1)
                            bound.update(b)
                            free.update(f)
                    else:
                        free.add((level,arg))
                return (bound,free)
            def sorted_by_level(args):  # level first, then name as tie-breaker
                return sorted(tuple(args), key=lambda item: (item[0], item[1]))
            def sorted_by_name(args):   # name first, then level as tie-breaker
                return sorted(tuple(args), key=lambda item: (item[1], item[0]))

            # Check that each call goes to a strictly deeper level, because our
            # code generation algorithm does not work for mutually recursive
            # call sequences.
            #
            # This guarantees the correctness (in this respect) of the
            # generated Fortran program.
            #
            def validate(bound):
                # find the deepest level where each bound arg was used
                args = [arg for (_,arg) in bound]
                arg_to_level = {}
                for arg in args:
                    maxlevel = max(l for (l,a) in bound if a == arg)
                    arg_to_level[arg] = maxlevel

                # check that all args *used by* each of our bound args
                # are at a strictly deeper level than the arg itself
                for arg,level in arg_to_level.items():
                    deps = lookup[arg]
                    for a in deps:
                        if a in args:  # if a is bound
                            al = arg_to_level[a]  # max level where a was seen
                            if al <= level:
                                raise ValueError("%s (max level %d) requires %s (max level %d); recursive calls not supported by this code generator" % (arg,level,a,al))

            # To write the wrapper for a function f, we need two things:
            #
            #  - free args needed by f or anything it calls, recursively
            #      -> add to arg list of wrapper
            #  - bound args needed by f, locally
            #      -> call them in the function body of the wrapper,
            #         then use the obtained values
            #
            # This binds values to all arguments of f; we may then assign
            # them to temporary variables and call the original f.
            #
            # Note that in any *calls*, we must use data from funcs
            # (or lookup), because they preserve the original ordering
            # of args (which are positional in Fortran!); the sets of
            # bound and free arguments are only used for deciding
            # which action to perform with each symbol.
            #
            for fname,args in funcs:
#                # DEBUG
#                print(fname)
#                for arg in args:
#                    print("\t%s" % (arg))

                rbound,rfree = analyze_args(args, recurse=True)   # r=recursive
                lbound,lfree = analyze_args(args, recurse=False)  # l=local
#                print(fname, lbound, rfree)
                print(fname, sorted_by_name(lbound), sorted_by_name(lfree))
                print(fname, sorted_by_name(rbound), sorted_by_name(rfree))
                validate(rbound)

#                output += "REAL*8 function %s

                # TODO: finish implementing this

#            output_basename = "mgs_%s" % (label)
#            output_implname = "%s.f90" % (output_basename)
#            output_intfname = "%s.h"   % (output_basename)

#            generated_code_output.append( (label, output_implname, output_impl) )
#            generated_code_output.append( (label, output_implname, output_intf) )

        return generated_code_output

##############################################################################
# Testing
##############################################################################

def test():
    # TODO: just load files to run s2 test faster?
    import stage1
    s1gen = stage1.CodeGenerator()
    s1code = s1gen.run()

    s2gen = CodeGenerator(s1code)  # stage2 i.e. ours
    s2code = s2gen.run()

    # TODO: write to files

if __name__ == '__main__':
    test()
