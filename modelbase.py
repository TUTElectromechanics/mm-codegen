#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Interface for models.

See model.py for a real-world usage example.

Created on Thu Nov  9 10:39:51 2017

@author: Juha Jeronen <juha.jeronen@tut.fi>
"""

from abc import ABCMeta, abstractmethod

import sympy as sy

class ModelBase:
    """Abstract base class for mathematical models of the category considered in this software."""
    __metaclass__ = ABCMeta

    def __init__(self):
        pass

    @abstractmethod
    def define_api(self):
        """Define API of mathematical functions for the end user.

        This is mainly meant to define chain rule based expressions for the
        derivatives of a SymPy applied function (i.e. unspecified function,
        but with specified dependencies), in terms of other SymPy applied
        functions, and at the final layer, in terms of independent variables.
        The independent variables are represented by bare SymPy symbols.

        For providing SymPy expressions that define the functions appearing
        on the RHS of the API expressions, see ``define_helpers()``. The stage1
        code generator will automatically generate Fortran code for them.

        Also, if the API expressions refer to any derivatives of the helpers,
        stage1 automatically performs the symbolic differentiation, and
        generates the corresponding Fortran code.

        Finally, stage1 generates Fortran code also for the API functions
        themselves.

        The stage2 code generator then resolves the dependencies between the
        functions generated by stage1, and builds the public API.

        Abstract method, must be overridden in a derived class.

        Must return:
            dictionary of ``sy.Symbol`` -> ``sy.Expr``
"""
        raise NotImplementedError("Abstract method; must be overridden in a derived class")

    @abstractmethod
    def define_helpers(self):
        """Define bound symbols for stage2 of code generation.

        The stage1 code generator emits Fortran code for all helpers
        defined here.

        Additionally, stage1 detects derivatives of these helpers in the RHS
        of the API functions (see ``define_api()``). It automatically performs
        symbolic differentiation, and emits Fortran code for any helper
        derivatives that are needed by any of the API functions.

        Only needed derivatives are handled; the helper quantities are
        considered internal to the mathematical model, and of no interest
        to the end user.

        Only references made directly by the RHS expressions of the API
        functions are detected. The API expressions are expected to be already
        flattened in the sense that all chain rule based dependencies are
        directly visible, so that there is no need to recurse.

        Abstract method, must be overridden in a derived class.

        Must return:
            dictionary of ``sy.Symbol`` -> ``sy.Expr``
"""
        raise NotImplementedError("Abstract method; must be overridden in a derived class")

    def simplify(self, expr):
        """Simplify expressions used by this model.

        Derived classes may override this to provide specific sequences of
        simplification operations that work particularly well with those
        particular expressions.

        This base class provides a generic fallback.
"""
        return sy.simplify(expr)
