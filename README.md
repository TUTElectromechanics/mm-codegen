# mm-codegen

Generate Fortran code for Elmer so that it can use our material model.

Technical details are documented in code comments.

Tested in Python 3.4.


## Getting started

The roles of the scripts are as follows:

 - [``main.py``](main.py): Top-level program to run the whole code generator in one go.
 - [``modelbase.py``](modelbase.py): Abstract base class that defines the API representing a mathematical model for the material. This allows later extending the program to support different material models.
 - [``model.py``](model.py): Specialization of ``ModelBase`` to our particular material model (based on the potential ϕ), as represented using SymPy.
 - [``stage1.py``](stage1.py): Take a SymPy model, generate a private Fortran 90 API.
 - [``stage2.py``](stage2.py): Take a stage1 API, and create the corresponding public Fortran 90 API.

Low-level utilities are located in:

 - [``iterutil.py``](iterutil.py): Utilities for iterables
 - [``memoize.py``](memoize.py): Instance method memoizer [recipe by Daniel Miller](https://github.com/ActiveState/code/tree/master/recipes/Python/577452_memoize_decorator_instance), used under [MIT license](https://github.com/ActiveState/code/blob/master/recipes/Python/577452_memoize_decorator_instance/LICENSE.md). Used for accelerating computation.
 - [``numutil.py``](numutil.py): Numerical utilities
 - [``reccollect.py``](reccollect.py): Recursive collect for SymPy, with a vengeance. In some applications (such as here), leads to shorter output expressions than SymPy's own `collect()` in recursive mode, since this implementation dynamically decides on which symbols to collect first as it goes along.
 - [``symutil.py``](symutil.py): Some custom utilities for SymPy, which is as much as [CAS](https://en.wikipedia.org/wiki/Computer_algebra_system) *construction kit* as it is a (relatively) complete CAS system.
 - [``util.py``](util.py): Miscellaneous utilities to make code generation easier; e.g. removal of Unicode Greek symbols, naming of derivatives, and adding line breaks to Fortran code.

Small independent programs provided for testing, development and documentation purposes:

 - [``converter.py``](converter.py): Convert B-spline basis functions to cubic-spline interpolated data in Elmer format. Note that this correspondence is very highly sensitive to the placement of the knots of the interpolation splines. For example, for the knot at the center of the span, even an [ulp](https://en.wikipedia.org/wiki/Unit_in_the_last_place) of difference can have a significant effect on the output.
 - [``elmerspline.py``](elmerspline.py): Python port of the cubic-spline routines in [Elmer's ``GeneralUtils.F90``](https://github.com/ElmerCSC/elmerfem/blob/devel/fem/src/GeneralUtils.F90), providing spline-based interpolation in the plane through given points. Not used in this project.
 - [``hermite_element.py``](hermite_element.py): SymPy code to automatically derive arbitrary-order 1D Hermite interpolation functions with *C<sup>k</sup>* continuity, interpolating a function and its first *k* derivatives. Not used in this project.
 - [``ppeval.py``](ppeval.py): Python evaluator for MATLAB's ppform splines in 2D, for evaluating the potential ϕ, based on its B-spline fit. The final version will contain a Fortran port of the necessary subset of ppeval.


To get a more detailed overview of what calls or defines what, consider running [Pyan3](https://github.com/Technologicat/pyan) on the code.


## Notes

The API is generated in two stages.

Stage1 reads the mathematical definitions from Model (represented using SymPy), and applies the chain rule to determine the first and second partial derivatives of ϕ with respect to the physical fields (independent variables), e.g. ∂²ϕ/∂Bx². It then generates code to evaluate the generated chain-rule expressions, along with the expressions each of these depends on.

After stage1, each generated function is a standalone piece, which requires as function arguments the values for all symbols that the expression refers to. This format is convenient to generate in SymPy, but inconvenient to use, since the same generated API contains also functions to compute the values for those arguments.

This is where stage2 comes in. It takes the interface generated by stage1, and analyzes the dependencies between the functions. It generates wrapper functions, where all bound symbols - i.e. quantities defined by any of the stage1 generated functions - are automatically computed, by calling the standalone pieces generated in stage1 and recursing where necessary.

Each function generated by stage2 takes in values only for the free symbols - i.e. quantities **not** defined by any of the stage1 generated functions - encountered anywhere in its call tree. This makes e.g. ∂²ϕ/∂Bx² "see" the dependencies on e.g. u0, I4, and εxx.


## Dependencies

Code generator:

 - [SymPy](http://www.sympy.org)

The small independent programs additionally need:

 - [NumPy](http://www.numpy.org)
   - needed by [``converter.py``](converter.py), [``elmerspline.py``](elmerspline.py), [``ppeval.py``](ppeval.py)
 - [SciPy](https://scipy.org)
   - needed by [``ppeval.py``](ppeval.py) to read ``.mat`` files
 - [Matplotlib](http://matplotlib.org)
   - needed by [``converter.py``](converter.py), [``elmerspline.py``](elmerspline.py), [``ppeval.py``](ppeval.py)
 - [bspline](https://github.com/johntfoster/bspline)
   - B-spline basis functions and utilities
   - needed by [``converter.py``](converter.py)


## Installation

For the Python dependencies, it is recommended to use the latest versions from ``pip`` (or ``conda``, depending on your Python distribution).

In addition to the Python dependencies, NumPy requires BLAS and LAPACK. In Debian-based distros, BLAS is available in the packages ``libblas3 libblas-dev`` (reference BLAS) or ``libopenblas-base libopenblas-dev`` (OpenBLAS). LAPACK is available in the packages ``liblapack3 liblapack-dev``.

To install all Python dependencies:

```bash
pip install --user cython numpy scipy matplotlib sympy bspline
```

(Cython may be needed for compiling NumPy; if so, the latest version is recommended.)

Then, finally, clone this project from git.


## License

[2-clause BSD](LICENSE.md)

``reccollect.py`` has been copied and adapted from the FREYA solver, Copyright 2012-2017 Juha Jeronen and University of Jyväskylä, 2-clause BSD license.

