#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Model that describes the needed partial derivatives of the potential ϕ
and the auxiliary quantities needed to compute them.

Note ϕ = ϕ(u,v,w).

The derivatives ∂ϕ/∂u, ∂ϕ/∂v, ∂ϕ/∂w must be externally supplied; all the other
required partial derivatives are automatically generated by this module.

Created on Tue Oct 24 14:07:45 2017

@author: jje
"""

from itertools import combinations_with_replacement

import sympy as sy

from memoize import memoize

# our custom reccollect seems to fare better in some cases than sy.rcollect
# (maybe due to autosyms?)
from reccollect import recursive_collect
import symutil
import util

from modelbase import ModelBase

# TODO: test the framework by defining another version that substitutes everything into the declaration (no separate exprs)

class Model(ModelBase):
    """Generate mathematical expressions for the spline-based (B,ε) model."""

    def __init__(self, kind="2par"):  # 2par, 3par
        """Constructor.

        Parameters:
            kind: str
                "2par" builds the 2-parameter model where ϕ = ϕ(u,v),
                using only the invariants I4 and I5.

                "3par" builds the 3-parameter model where ϕ = ϕ(u,v,w),
                using all three invariants I4, I5 and I6.
"""

        if kind not in ("2par", "3par"):
            raise ValueError("Unknown kind '%s'; valid: '2par', '3par'" % (kind))
        self.kind = kind

        # es and εs are listed in Voigt notation ordering:
        #   ε = [[ε1, ε6, ε5], = [[εxx, εxy, εzx],
        #        [ε6, ε2, ε4],    [εxy, εyy, εyz],
        #        [ε5, ε4, ε3]]    [εzx, εyz, εzz]]
        #
        self.Bs = sy.symbols("Bx, By, Bz")
        self.εs = sy.symbols("εxx, εyy, εzz, εyz, εzx, εxy")

        # All independent variables
        #
        self.indepvars = {s.name:s for s in self.Bs + self.εs}

        # Deviatoric strain.
        #
        # Essentially, the code here tells SymPy that e = e(ε),
        # without defining what its expression is.
        #
        # We use the component form, because sy.diff() cannot differentiate
        # with regard to a sy.MatrixSymbol. The component form also readily
        # lends itself to a Fortran conversion.
        #
        λexx,λeyy,λezz,λeyz,λezx,λexy = sy.symbols("exx, eyy, ezz, eyz, ezx, exy", cls=sy.Function)
        exx = λexx(*self.εs)
        eyy = λeyy(*self.εs)
        ezz = λezz(*self.εs)
        eyz = λeyz(*self.εs)
        ezx = λezx(*self.εs)
        exy = λexy(*self.εs)
        self.es = (exx,eyy,ezz,eyz,ezx,exy)

    # For the same instance of Model, ϕ is always the same, so cache the result
    # to speed things up (especially in the 3-parameter case, where we generate
    # many partial derivatives of ϕ).
    #
    @memoize
    def build_ϕ(self):
        """Build and return ϕ as a SymPy applied function."""
        # Undefined functions.
        #
        # An "undefined function" is a symbol for a generic unknown function
        # having the given name. Here e.g. up = "u prime".
        #
        # Each function must have a unique symbol name, since SymPy
        # distinguishes between different symbols by symbol name, flags
        # and Python object type (e.g. sy.Symbol vs. sy.Function).
        #
        λI4,λI5,λI6 = sy.symbols("I4, I5, I6", cls=sy.Function)
        λup,λvp,λwp = sy.symbols("up, vp, wp", cls=sy.Function)
        λu,λv,λw = sy.symbols("u, v, w", cls=sy.Function)
        λϕ = sy.symbols("ϕ", cls=sy.Function)

        # Applied functions (of symbols).
        #
        # In SymPy, calling an undefined function object, with symbols as parameters,
        # returns an unknown function that formally depends on the given symbols.
        #
        # SymPy creates a new Python type (class) for each function name,
        # using the symbol name of the undefined function instance as the
        # name of the new Python type. E.g. type(λI4(Bx,By,Bz)) = I4.
        #
        I4 = λI4(*self.Bs)  # i.e. in mathematical notation, I4 = I4(Bx, By, Bz)
        I5 = λI5(*(self.Bs + self.es))
        I6 = λI6(*(self.Bs + self.es))

        # Create applied functions of other applied functions; they are also symbols.
        #
        up = λup(I4)
        vp = λvp(I4, I5)
        wp = λwp(I4, I5, I6)

        # u',v',w' are the raw unscaled u,v,w.
        #
        # The final u,v,w are normalized (by scaling by a constant), as follows:
        #
        #  u ∈ [ 0,1]
        #  v ∈ [-1,1]
        #  w ∈ [-1,1]
        #
        u = λu(up)  # ...but here we only declare an arbitrary formal dependency
        v = λv(vp)
        w = λw(wp)

        # Finally, the normalized u,v,w are the formal arguments of ϕ:
        #
        if self.kind == "2par":
            ϕ = λϕ(u,v)
        else: # self.kind == "3par":
            ϕ = λϕ(u,v,w)

        return ϕ

    def define_api(self):
        """See docstring for ``ModelBase.define_api()``."""

        results = {}

        # For the sake of completeness, we also provide a function to evaluate
        # ϕ itself, in terms of our independent variables. Here we generate
        # just "ϕ"; the stage2 code generator will do the rest, when it
        # notices that the interfaces input to it declare Fortran functions
        # for ϕ, u, v and w.
        #
        # We cannot use the name "ϕ" for the exported symbol, because ppeval
        # supplies a function "phi" (with which "ϕ" would conflict after
        # degreeking), and the expr on the RHS must refer to the "phi"
        # from ppeval. Hence we name it "ϕ_Bε", which becomes "phi_Beps".
        #
        print("model: %s forming expression for ϕ" % (self.kind))
        sym,expr = self.dϕdq(qs=(), strip=True)
        results[sy.symbols("ϕ_Bε")] = expr

        # All 1st and 2nd derivatives of ϕ.
        #
        independent_vars = sorted(self.indepvars.keys())
        secondder_varlists = combinations_with_replacement(independent_vars, 2)

        allqs = [(var,) for var in independent_vars]  # wrap each in tuple
        allqs.extend(secondder_varlists)

#        allqs = (("Bx",), ("Bx","Bx"),)  # DEBUG

        for i,qs in enumerate(allqs):
            print("model: %s (%d/%d) forming expression for %s" % (self.kind, i+1, len(allqs), util.name_derivative("ϕ", qs)))
            # strip kilometer-long nested arg lists (replace applied functions with bare symbols)
            sym,expr = self.dϕdq(qs, strip=True)
            results[sym] = expr

        return results

    # Differentiate ϕ with respect to a variable, applying the chain rule.
    #
    def dϕdq(self, qs, strip):
        """Formally differentiate ϕ w.r.t. given independent variables, applying the chain rule.

        self.indepvars.keys() contains all independent variables recognized by this routine.

        Parameters:
            qs: tuple of str
                Names of independent variables to differentiate with regard to.
                An empty list means no differentiation; return the function ϕ itself.

            strip: bool
                If True, pass the generated expr through symutil.strip_function_arguments()
                before returning it (replacing applied functions with bare symbols).

                If False, return the generated expr as-is.

        Example:
            m = Model(kind="2par")
            m.dϕdq(("Bx",), strip=True)      # ∂ϕ/∂Bx
            m.dϕdq(("Bx","Bx"), strip=True)  # ∂²ϕ/∂Bx²
            m.dϕdq(("Bx","By"), strip=True)  # ∂²ϕ/∂BxBy

        Returns:
            tuple (sym, expr)
"""
        # check precondition
        invalid_inputs = [q for q in qs if q not in self.indepvars]
        if len(invalid_inputs):
            raise ValueError("Invalid input: variable(s) %s not in self.indepvars" % (", ".join(invalid_inputs)))

        # For the Symbol representing the function name, we can't use a
        # bare Symbol (i.e. a variable, not a function), because even with
        # evaluate=False, SymPy thinks that sy.diff(Derivative(ϕ, Bx), By) = 0,
        # if ϕ is a bare Symbol.
        #
        # Since all possible qs are in self.indepvars, we can use the following
        # strategy to generate a bare Symbol that represents the name:
        #
        # We first make an unknown function ϕ; then convert it to an applied
        # function that depends on all indepvars; then perform any requested
        # differentiations on that; and finally strip the argument lists from
        # the result, producing a bare Symbol.
        #
        λϕ = sy.symbols("ϕ", cls=sy.Function)
        sym = λϕ(*self.indepvars.values())  # note: *Symbols* of the indepvars

        # For the expression part (RHS of the API function being generated),
        # we use the layer cake version of ϕ, which depends on u, v, w;
        # which then depend on... and so on, until the independent variables
        # are reached.
        #
        # When we differentiate this, SymPy will apply the chain rule
        # automatically.
        #
        expr = self.build_ϕ()

        # In SymPy, differentiating an unknown function gives an unapplied
        # Subs (mathematical substitution) object instance:
        #   http://docs.sympy.org/latest/_modules/sympy/core/function.html
        for varname in qs:
            q    = self.indepvars[varname]
            sym  = sy.diff(sym, q, evaluate=False)
            expr = sy.diff(expr, q)
        sym = symutil.strip_function_arguments(sym)  # always strip the name

        # Apply the Subs object to eliminate the dummy variables in the
        # derivative expressions. E.g.
        #
        #   d/dξ1( ϕ(ξ1,v,w) )|ξ1=u  -->  d/du( ϕ(u,v,w) )
        #
        # The first expression is what the second one, strictly speaking,
        # actually means: first, differentiate ϕ w.r.t. the formal argument "u";
        # and then, in the result, set the value of this formal argument
        # to the current value of u.
        #
        # The second expression is the standard human-readable notation.
        #
        # In SymPy, applying the Subs object returned by diff() converts
        # the derivative expressions to the human-readable notation.
        #
        if len(qs):  # if we did any differentiations
            expr = symutil.doit_in(expr)

        if strip:
            expr = symutil.strip_function_arguments(expr)

        # check postcondition
        assert sym != 0, "BUG in dϕdq(): symbol for function name is 0"

        return (sym, expr)

    def define_helpers(self):
        """See docstring for ``ModelBase.define_helpers()``."""

        results = {}

        print("model: %s defining auxiliary expressions" % (self.kind))

        Bx,By,Bz = self.Bs
        εxx,εyy,εzz,εyz,εzx,εxy = self.εs

        # Voigt notation ordering:
        #   ε = [[ε1, ε6, ε5],
        #        [ε6, ε2, ε4],
        #        [ε5, ε4, ε3]]
        #
        B = sy.Matrix( [Bx, By, Bz] )
        ε = sy.Matrix( [[εxx, εxy, εzx],  # Cauchy strain
                        [εxy, εyy, εyz],
                        [εzx, εyz, εzz]] )

        # Deviatoric strain.
        #
        # Here we ignore that e = e(ε); the es are just arbitrary symbols.
        #
        exx,eyy,ezz,eyz,ezx,exy = sy.symbols("exx, eyy, ezz, eyz, ezx, exy")
        e = sy.Matrix( [[exx, exy, ezx],
                        [exy, eyy, eyz],
                        [ezx, eyz, ezz]] )

        εM_expr = sy.factor(sy.S("1/3") * ε.trace())  # mean volumetric strain
        e_expr  = ε - εM_expr * sy.eye(3)
        assert e_expr[1,0] == e_expr[0,1]  # exy
        assert e_expr[2,0] == e_expr[0,2]  # ezx
        assert e_expr[1,2] == e_expr[2,1]  # eyz
#        results["εM"] = εM_expr  # not needed separately since the expression is inserted
        results[sy.symbols("exx")] = e_expr[0,0]
        results[sy.symbols("eyy")] = e_expr[1,1]
        results[sy.symbols("ezz")] = e_expr[2,2]
        results[sy.symbols("eyz")] = e_expr[1,2]
        results[sy.symbols("ezx")] = e_expr[0,2]
        results[sy.symbols("exy")] = e_expr[0,1]

        # I4, I5, I6 in terms of (B,e)
        #
        for k,v in (("I4", B.T * B),
                    ("I5", B.T * e * B),
                    ("I6", B.T * e * e * B)):
            if self.kind == "2par" and k == "I6":  # 2-parameter model does not use I6
                continue
            assert v.shape == (1,1)  # result should be scalar
            expr = v[0,0]  # extract scalar from matrix wrapper
            expr = self.simplify(expr)
            results[sy.symbols(k)] = expr

        # u', v', w' in terms of (I4,I5,I6)
        #
        I4,I5,I6 = sy.symbols("I4, I5, I6")
        for k,v in (("up", sy.sqrt(I4)),
                    ("vp", sy.S("3/2") * I5 / I4),
                    ("wp", sy.sqrt(I6*I4 - I5**2) / I4)):
            if self.kind == "2par" and k == "wp":  # 2-parameter model does not use wp
                continue
            results[sy.symbols(k)] = v  # here no simplifications are possible, so just save.

        # u, v, w in terms of (u',v',w')
        #
        u,v,w = sy.symbols("u, v, w")
        u0,v0,w0 = sy.symbols("u0, v0, w0")
        for k,v in (("u", "up / u0"),
                    ("v", "vp / v0"),
                    ("w", "wp / w0")):
            if self.kind == "2par" and k == "w":  # 2-parameter model does not use w
                continue
            results[sy.symbols(k)] = v

        return results

    def simplify(self, expr):
        """Simplify expr.

        This particular sequence of simplification operations is specifically
        targeted for the expressions treated by this class.
"""
        #   - expand() first to expand all parentheses; this gives a form
        #     that can then be grouped back differently (i.e. optimized)
        #   - together() to combine rationals
        #   - recursive_collect() automatically detects symbols in expr
        #     and collect()s in all of them, recursively.
        #     This typically reduces the operation count.
        #   - But this may leave "leftovers" in some parts of expr;
        #     e.g. for dI6/dBx, reccollect.analyze() gives
        #     [exy, ezx, By, Bx, Bz, exx, eyz, ezz, eyy]
        #     because that is overall more optimal (by the metric used
        #     by reccollect.analyze()) than going "B first".
        #   - This causes some duplication of Bx in terms that have been
        #     collected on [exy, ezx], in parts of expr where "B first"
        #     would have been a better ordering.
        #   - To fix this specifically for the kind of expressions
        #     we work with here, we then collect again, explicitly on self.Bs
        #     (disabling the automatic detection, which would still give the wrong symbols).
        #   - Finally, collect_const_in() extracts each constant factor to the
        #     topmost possible level in the expression.
        #
        expr = recursive_collect(sy.together(sy.expand(expr)))
        expr = recursive_collect(expr, syms=self.Bs)
        expr = symutil.collect_const_in(expr)
        return expr

##############################################################################
# Main program (stage1 only)
##############################################################################

def main():
    for kind in ("2par", "3par"):
        m = Model(kind)
        print(m.kind)

        api = m.define_api()
        scrub = symutil.derivatives_to_names_in
        api_humanreadable = {scrub(k):scrub(v) for k,v in api.items()}
        print(api_humanreadable)

        print(m.define_helpers())

if __name__ == '__main__':
    main()
