#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Code generator for evaluating the partial derivatives of the potential ϕ.

Note ϕ = ϕ(u,v,w). The direct partial derivatives ∂ϕ/∂u, ∂ϕ/∂v, ∂ϕ/∂w,
the scalings u0,v0,w0 (of u = u'/u0 et al.), and the physical fields Bx,By,Bz,
εxx,εyy,εzz,εyz,εzx,εxy must be externally supplied; everything else is
automatically generated.

stage1.py makes the appropriate mathematical definitions using SymPy,
and applies the chain rule to determine the first and second partial
derivatives of ϕ with respect to the physical fields, e.g. ∂²ϕ/∂Bx².

It then generates code to evaluate the generated chain-rule expressions,
along with the expressions each of these depends on.

At stage1, each generated function is a standalone piece, which requires as
function arguments the values for all symbols that the expression refers to.
This format is convenient to generate in SymPy.

This is where stage2 comes in.

stage2.py takes in the code generated by stage1. It analyzes the dependencies
between the functions, and generates wrapper functions, where all bound symbols
(quantities defined by any of the stage1 generated functions) are automatically
computed, by calling the standalone pieces generated in stage1 (recursing
where necessary).

Each function generated by stage2 takes in values only for the free symbols
(quantities *not* defined by any of the stage1 generated functions)
encountered anywhere in its call tree. This makes e.g. ∂²ϕ/∂Bx² "see" the
dependencies on e.g. u0, I4, and εxx.

Created on Mon Nov  6 13:32:31 2017

@author: Juha Jeronen <juha.jeronen@tut.fi>
"""

__version__ = '1.0.0'

import argparse

def run(stage):
    assert stage in (1, 2)

    if stage == 1:
        import stage1
        stage1.main()
    else: # stage == 2:
        import stage2
        stage2.main()

def main():
    parser = argparse.ArgumentParser(description="""Code generator for elmer-mgs-galfenol.""",
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument( '-v', '--version', action='version', version=('%(prog)s ' + __version__) )

    group_behavior = parser.add_argument_group('behavior', 'Behavior options.')
    group_behavior.add_argument('-s1', '--stage1-only', dest='s1_only', default=False, action='store_true',
                                help='Run stage1 (model to internal API) only.' )
    group_behavior.add_argument('-s2', '--stage2-only', dest='s2_only', default=False, action='store_true',
                                help='Run stage2 (internal API to public API) only.' )

    opts = vars(parser.parse_args())
    enabled = lambda x: x in opts and opts[x] == True

    if all(enabled(x) for x in ("s1_only", "s2_only")):
        raise ValueError("Cannot specify both -s1 and -s2.")
    elif enabled("s1_only"):
        stages = (1,)
    elif enabled("s2_only"):
        stages = (2,)
    else:
        stages = (1, 2)

    for stage in stages:
        run(stage)

if __name__ == '__main__':
    main()
