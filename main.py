#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Code generator for evaluating the partial derivatives of the potential ϕ.

Note ϕ = ϕ(u,v,w). The direct partial derivatives ∂ϕ/∂u, ∂ϕ/∂v, ∂ϕ/∂w,
the scalings u0,v0,w0 (of u = u'/u0 et al.), and the physical fields Bx,By,Bz,
εxx,εyy,εzz,εyz,εzx,εxy must be externally supplied; everything else is
automatically generated.

stage1.py makes the appropriate mathematical definitions using SymPy,
and applies the chain rule to determine the first and second partial
derivatives of ϕ with respect to the physical fields, e.g. ∂²ϕ/∂Bx².

It then generates code to evaluate the generated chain-rule expressions,
along with the expressions each of these depends on.

At stage1, each generated function is a standalone piece, which requires as
function arguments the values for all symbols that the expression refers to.
This format is convenient to generate in SymPy.

This is where stage2 comes in.

stage2.py takes in the code generated by stage1. It analyzes the dependencies
between the functions, and generates wrapper functions, where all bound symbols
(quantities defined by any of the stage1 generated functions) are automatically
computed, by calling the standalone pieces generated in stage1 (recursing
where necessary).

Each function generated by stage2 takes in values only for the free symbols
(quantities *not* defined by any of the stage1 generated functions)
encountered anywhere in its call tree. This makes e.g. ∂²ϕ/∂Bx² "see" the
dependencies on e.g. u0, I4, and εxx.

Created on Mon Nov  6 13:32:31 2017

@author: jje
"""

# code generators
import stage1
import stage2

##############################################################################
# Main program
##############################################################################

def main():
    s1gen = stage1.CodeGenerator()
    s1code = s1gen.run()

    for label,filename,content in s1code:
        print("stage1: writing %s for %s" % (filename, label))
        with open(filename, "wt", encoding="utf-8") as f:
            f.write(content)

    s2gen = stage2.CodeGenerator(s1code)
    s2code = s2gen.run()

    # TODO: write to files

if __name__ == '__main__':
    main()
