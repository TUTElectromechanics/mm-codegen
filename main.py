#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Code generator for evaluating the partial derivatives of the potential ϕ.

Note ϕ = ϕ(u,v,w).

The derivatives ∂ϕ/∂u, ∂ϕ/∂v, ∂ϕ/∂w must be externally supplied; all the rest
are automatically generated by this module.

Created on Tue Oct 24 14:07:45 2017

@author: jje
"""

import sympy as sy
from sympy.utilities.codegen import codegen

# our custom reccollect seems to fare better in some cases than sy.rcollect
# (maybe due to autosyms?)
from reccollect import recursive_collect
from symutil import strip_function_arguments, find_needed_derivatives, collect_const_in

##############################################################################
# Local utilities
##############################################################################

def print_and_count(expr, name=None, pretty=False, count_visual=True):
    """Print a symbolic expression and its operation count."""
    if pretty:
        printer = sy.pprint
    else:
        printer = print

    if name is not None:
        printer(name)

    printer(expr)
    print(sy.count_ops(expr, visual=count_visual))
    print("=" * 80)  # separator

##############################################################################
# Expression generator
##############################################################################

class SymbolicModelDeriver:
    """Mathematical definitions."""

    def __init__(self):
        # es and εs are listed in Voigt notation ordering:
        #   ε = [[ε1, ε6, ε5], = [[εxx, εxy, εzx],
        #        [ε6, ε2, ε4],    [εxy, εyy, εyz],
        #        [ε5, ε4, ε3]]    [εzx, εyz, εzz]]
        #
        self.Bs = sy.symbols("Bx, By, Bz", real=True)
        self.es = sy.symbols("exx, eyy, ezz, eyz, ezx, exy", real=True)
        self.εs = sy.symbols("εxx, εyy, εzz, εyz, εzx, εxy", real=True)
#        fargs = (Bx, By, Bz, εxx, εyy, εzz, εyz, εzx, εxy)  # parameters for callables (which are generated later)

        # Symbol dictionary  name: object instance
        #
        symdic = {}
        for s in self.Bs + self.es + self.εs:  # these are lists, so + concatenates
            symdic[s.name] = s
        self.symdic = symdic

    # Differentiate ϕ with respect to a variable, applying the chain rule.
    # See self.symdic.keys() for valid vars.
    #
    def dϕdq(self, diff_wrt="Bx"):
        """Formally differentiate ϕ w.r.t. given variable, using the chain rule."""
        # How to chain rule in SymPy:
        # https://stackoverflow.com/questions/34786224/chain-rule-in-sympy

        # Start by defining "undefined functions".
        #
        # An "undefined function" is a symbol for a generic unknown function
        # having the given name. Here e.g. up = "u prime".
        #
        # It is important that each function (that is intended to be a separate
        # mathematical object) has a unique name, since in SymPy, the symbol name
        # defines the identity of a symbol (i.e. distinguishes between different symbols).
        #
        # Strictly speaking, in order for two symbols to be the same in SymPy,
        # their name, flags and type must match. E.g.:
        #
        #   x1 = sy.symbols("x")
        #   x2 = sy.symbols("x")
        #   x2 == x1  # True, both x1 and x2 refer to the same SymPy symbol "x"
        #   x2 is x1  # False, x1 and x2 are *not* the same Python object instance!
        #
        #   x3 = sy.symbols("x", real=True)
        #   x3 == x1  # False, x3 is real whereas x1 is general
        #
        #   x4 = sy.symbols("x", cls=sy.Function)
        #   x4 == x1  # False, x4 is a function whereas x1 is not
        #   type(x4)  # sympy.core.function.UndefinedFunction
        #   type(x1)  # sympy.core.symbol.Symbol
        #
        # We use the name "λf" for the Python object representing the
        # mathematical function "f", loosely following the convention
        # that a "lambda expression" is a function.
        #
        λI4,λI5,λI6,λup,λvp,λwp,λu,λv,λw,λϕ = sy.symbols("I4, I5, I6, up, vp, wp, u, v, w, ϕ", cls=sy.Function)

        # TODO: we actually need ∂ϕ/∂ε; add another layer so that e = e(ε).
        # Maybe component form, λexx(self.εs), ..., λezz(self.εs) ?

        # Applied functions (of symbols).
        #
        # In SymPy, calling an undefined function instance, with symbols as parameters,
        # returns an unknown function that formally depends on the given symbols.
        #
        # Technically, SymPy creates a new Python type (class) for each function name,
        # using the symbol name of the undefined function instance as the name
        # of the new Python type. E.g. type(λI4(Bx,By,Bz)) = I4.
        #
        # In Python, *L unpacks iterable L to separate function arguments:
        # f(*L) = f(L[0], L[1], ..., L[-1])
        #
        I4 = λI4(*self.Bs)  # i.e. in mathematical notation, I4 = I4(Bx, By, Bz)
        I5 = λI5(*(self.Bs + self.es))
        I6 = λI6(*(self.Bs + self.es))

        # Now we build the chain by creating applied functions of other applied functions;
        # they are also symbols.
        #
        up = λup(I4, I5, I6)
        vp = λvp(I4, I5, I6)
        wp = λwp(I4, I5, I6)

        # u',v',w' are raw unscaled u,v,w.
        #
        # The final u,v,w are normalized (by scaling by a constant), as follows:
        #
        #  u ∈ [ 0,1]
        #  v ∈ [-1,1]
        #  w ∈ [-1,1]  (TODO: check w)
        #
        u = λu(up)
        v = λv(vp)
        w = λw(wp)

        # Finally, the normalized u,v,w are the arguments ϕ formally depends on:
        #
        ϕ = λϕ(u,v,w)

        # Now we can differentiate. SymPy will apply the chain rule automatically.
        #
        # In SymPy, differentiating an unknown function gives an unapplied
        # Subs (mathematical substitution) object instance:
        #   http://docs.sympy.org/latest/_modules/sympy/core/function.html
        #
        q = self.symdic[diff_wrt]  # q = Bx, By, Bz, exx, ...
        dϕdq = sy.diff(ϕ, q)

        # Apply the Subs object to eliminate the dummy variables in the
        # derivative expressions. E.g.
        #
        #   d/dξ1( ϕ(ξ1,v,w) )|ξ1=u  -->  d/du( ϕ(u,v,w) )
        #
        # The first expression is what the second one, strictly speaking,
        # actually means: first, differentiate ϕ w.r.t. the formal argument "u";
        # and then, in the result, set the value of this formal argument
        # to the current value of u.
        #
        # The second expression is the standard human-readable notation.
        #
        # In SymPy, applying the Subs object returned by diff() converts
        # the derivative expressions to the human-readable notation.
        #
        dϕdq = dϕdq.doit()
        results_3par = { "name": "∂ϕ/∂%s" % (q),
                         "expr": strip_function_arguments(dϕdq),
                         "ders": find_needed_derivatives(dϕdq) }

        # Specialize to the 2-parameter model by taking w → 0, I6 → 0.
        #
        # - After the subs(), the first .doit() notices that d(0)/dwp = 0 and
        #   deletes the corresponding set of terms, but also re-introduces
        #   the dummy variables into the derivative expressions.
        #
        # - The second .doit() rewrites the derivatives again, without the
        #   dummy variables.
        #
        zero = sy.S.Zero
        tmp = dϕdq.subs( {w: zero, I6: zero} ).doit().doit()
        results_2par = { "name": "∂ϕ/∂%s" % (q),
                         "expr": strip_function_arguments(tmp),
                         "ders": find_needed_derivatives(tmp) }

        return { "3par" : results_3par, "2par" : results_2par }

    # Make symbolic expressions of the various intermediate functions.
    #
    def make_exprs(self):
        """Create auxiliary expressions I4, I5, I6, u', v', w', u, v, w."""
        results = {}

        Bx,By,Bz = self.Bs
        exx,eyy,ezz,eyz,ezx,exy = self.es
        εxx,εyy,εzz,εyz,εzx,εxy = self.εs

        # Voigt notation ordering:
        #   ε = [[ε1, ε6, ε5],
        #        [ε6, ε2, ε4],
        #        [ε5, ε4, ε3]]
        #
        B = sy.Matrix( [Bx, By, Bz] )
        ε = sy.Matrix( [[εxx, εxy, εzx],  # Cauchy strain
                        [εxy, εyy, εyz],
                        [εzx, εyz, εzz]] )
        e = sy.Matrix( [[exx, exy, ezx],  # deviatoric strain
                        [exy, eyy, eyz],
                        [ezx, eyz, ezz]] )

        # TODO: in the generated Fortran code, get rid of unicode symbols
        #
        # TODO: what is the best pratical way to create a Fortran subroutine for ε ↦ e?
        #
        # e in terms of ε
        #
        εM = sy.symbols("εM", real=True)  # mean volumetric strain
        e_expr  = ε - εM * sy.eye(3)
        εM_expr = sy.factor(sy.S("1/3") * ε.trace())
        results["e"]  = e_expr
        results["εM"] = εM_expr

        # I4, I5, I6 in terms of (B,e)
        #
        for k,v in (("I4", B.T * B),
                    ("I5", B.T * e * B),
                    ("I6", B.T * e * e * B)):
            assert v.shape == (1,1)
            expr = v[0,0]  # extract scalar from matrix wrapper
            expr = collect_const_in(recursive_collect(sy.expand(expr)))
            results[k] = expr

        # u', v', w' in terms of (I4,I5,I6)
        #
        # Note: here I4, I5 and I6 are just arbitrary symbols.
        #
        # We do not insert their expressions; that would only generate
        # unnecessary flops due to common subexpressions.
        #
        # (Also: we can't easily make the symbols here real-valued;
        #  this would make them different from symbols *of the same name*
        #  that do not have the flag. Hence e.g. d(up)/d("I4") would be zero,
        #  because it is not the same I4 due to the type difference.
        #
        #  The "diff w.r.t. what" symbols returned by find_needed_derivatives()
        #  currently do not have the real-valued flag set.)
        #
        I4,I5,I6 = sy.symbols("I4, I5, I6")
        for k,v in (("up", sy.sqrt(I4)),
                    ("vp", sy.S("3/2") * I5 / I4),
                    ("wp", sy.sqrt( I6*I4 - I5**2 ) / I4)):
            results[k] = v

        # u, v, w in terms of (u',v',w')
        #
        u,v,w = sy.symbols("u, v, w")
        u0,v0,w0 = sy.symbols("u0, v0, w0")
        for k,v in (("u", "up / u0"),
                    ("v", "vp / v0"),
                    ("w", "wp / w0")):
            results[k] = v

        return results

##############################################################################
# Main program
##############################################################################

def main():
    """Generate Fortran code for both 2-parameter and 3-parameter models."""
    smd = SymbolicModelDeriver()

    # Compute expressions for e, I4, I5, I6, u', v', w', u, v, w
    #
    exprs = smd.make_exprs()

    # Compute ∂ϕ/∂q for q = Bx, By, Bz, exx, ...
    #
    # The full strain ε is not used in our definition of ϕ,
    # so we differentiate only w.r.t. the components of B and e.
    #
    results = {}
    for q in [key for key in smd.symdic.keys() if not key.startswith("ε")]:  # production
#    for q in ("Bx",):  # DEBUG
        print("Computing ∂ϕ/∂%s" % (q))
        funcname = "dphi_d%s" % (q)  # Fortran routine name
        results[funcname] = smd.dϕdq(q)

    # We now have 2-parameter and 3-parameter models for the same function
    # in a single results item. Convert this to a format with all 2-parameter
    # models in one place, and all 3-parameter models in another.
    #
    all_results_2par = { k: v["2par"] for k,v in results.items() }
    all_results_3par = { k: v["3par"] for k,v in results.items() }
    all_results = ( ("2par", all_results_2par),
                    ("3par", all_results_3par) )

    for label,dic in all_results:  # 2par, 3par
        print("%s model" % (label))
        all_funcs = {}
        all_derivatives = {}
        for funcname in sorted(dic.keys()):  # process the functions in alphabetical order
            data = dic[funcname]
            sy.pprint(data["name"])  # sy.pprintable expression
            sy.pprint(data["expr"])

            print("Derivatives needed by %s; format (f, var):" % (data["name"]))
            sy.pprint(data["ders"])
            print("=" * 80)  # separator

            # Compute the derivatives ∂ϕ/∂q depends on.
            #
            derivatives = {}
            for func,var in data["ders"]:
                fname = str(func)  # func and var themselves are sy.Symbols
                vname = str(var)
                if fname == "ϕ":
                    continue  # in the solver, ϕ(u,v,w) comes from ppeval
                k = sy.Derivative(func, var, evaluate=False)  # this is present in expr; also a label
                v = sy.diff(exprs[fname], var)  # do it to the actual definition
                # simplify:
                #   - expand() first to get rid of parentheses;
                #     this gives a form that can be optimized
                #   - together() to combine rationals
                #   - recursive_collect() automatically detects symbols in expr
                #     and collect()s in all of them, recursively.
                #     This typically reduces the operation count.
                #   - But this may leave "leftovers" in some parts of expr;
                #     e.g. for dI6/dBx, reccollect.analyze() gives
                #     [exy, ezx, By, Bx, Bz, exx, eyz, ezz, eyy]
                #     because that is overall more optimal than going "B first".
                #     This causes some duplication of Bx in terms that have been
                #     collected on [exy, ezx], in parts of expr where "B first"
                #     would have been a better ordering.
                #   - To fix this specifically for the kind of expressions
                #     we work with here, we then collect again, now on B.
                #   - Finally, collect_const_in() extracts all constant factors.
                v = recursive_collect(sy.together(sy.expand(v)))
                v = recursive_collect(v, syms=smd.Bs)
                v = collect_const_in(v)
                # we will need fname,vname for generating the Fortran routine name
                derivatives[k] = (v, fname, vname)
                sy.pprint(k)
                sy.pprint(v)
                print("=" * 80)  # separator

            # Delete any terms that are identically zero due to the structure
            # of the functional dependencies.
            #
            print("Final expr, with zero terms eliminated:")
            zero = sy.S.Zero
            out = data["expr"]
            for k,val in derivatives.items():
                v,_,_ = val
                if v == zero:
                    out = out.subs( {k: zero} )
            sy.pprint(out)
            print("=" * 80)  # separator
            print("=" * 80)  # separator

            # Only include derivatives that are nonzero.
            #
            final_derivatives = { k:v for k,v in derivatives.items() if v[0] != zero }

            # We may overwrite, since e.g. dI4/dBx always has the same expression if it is present.
            all_derivatives.update(final_derivatives)
            all_funcs[funcname] = out

        # Generate the Fortran code

        # Auxiliary expressions I4, I5, I6, u', v', w', u, v, w
        #
        # (these are always generated)
        #
        name_expr_pairs = []
        if label == "2par":  # FIXME: parameterize better so no need for special handling
            cond = lambda k: k not in ("I6", "wp", "w")
        else:
            cond = lambda k: True
        name_expr_pairs = [ (k,v) for k,v in exprs.items() if cond(k) ]
        name_expr_pairs.sort()  # alphabetize helpers for easy reading of generated code

        # Derivatives of auxiliary expressions
        #
        # (only the ones we actually need)
        #
        derivative_routines = {}
        tmp_pairs = []
        for k,val in all_derivatives.items():
            v,fname,vname = val
            routine_name = "d%s_d%s" % (fname, vname)  # e.g. dI4_dBx
            derivative_routines[k] = routine_name
            tmp_pairs.append( (routine_name, v) )
        tmp_pairs.sort()
        name_expr_pairs.extend(tmp_pairs)

        # The main routines
        #
        # We alphabetize; the reverse is needed because we insert at the beginning.
        #
        for funcname in reversed(sorted(all_funcs.keys())):
            # TODO: 2nd-order derivatives for e.g. ∂H/∂B = ∂²ϕ/∂B², needed by Newton solver
            #
            final_expr = all_funcs[funcname]
            for k,v in derivative_routines.items():
                final_expr = final_expr.subs({k: v})
            ϕ,u,v,w = sy.symbols("ϕ, u, v, w")
            final_expr = final_expr.subs({sy.Derivative(ϕ,u) : "dphi_du"})
            final_expr = final_expr.subs({sy.Derivative(ϕ,v) : "dphi_dv"})
            final_expr = final_expr.subs({sy.Derivative(ϕ,w) : "dphi_dw"})
            final_expr = final_expr.subs({ϕ : "phi"})

            name_expr_pairs.insert(0, (funcname, final_expr))
    
        basename = "mgs_%s" % (label)
        generated_code = codegen(name_expr_pairs,
                                 language="f95",
                                 project="elmer-mgs-galfenol",
                                 to_files=True,
                                 prefix=basename)
#        print(generated_code)  # DEBUG


if __name__ == '__main__':
    main()
